name: build

on:
  push:
    branches:
      - "main"
  pull_request:
  workflow_dispatch:
  inputs:
    envToDeploy:
      type: choice
      description: Deploy to prod (all regions)?
      required: true
      options:
        - sandbox (sa-east-1)
        - prod (all regions)
    mfaCode:
      type: string
      description: MFA Code
      required: true

jobs:
  lint:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node 16.14
        uses: actions/setup-node@v3
        with:
          node-version: 16.14

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Restore node modules from cache
        id: cache-node-modules
        uses: actions/cache@v3
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Install dependencies
        run: yarn install

      - name: Check formatting
        run: yarn check-formatting

      - name: Lint
        run: yarn lint

  unit-test:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 4
      matrix:
        node-version: [12.13, 14.15, 16.14]
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up Node ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Restore node modules from cache
        id: cache-node-modules
        uses: actions/cache@v3
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Install dependencies
        run: yarn install

      - name: Build
        run: yarn build

      - name: Run tests
        run: yarn test

      - name: Upload code coverage report
        run: bash <(curl -s https://codecov.io/bash)

  integration-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        runtime-param: [12, 14, 16]
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up Node 14
        uses: actions/setup-node@v3
        with:
          node-version: 14

      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2

      - name: Complete Buildx Setup
        run: docker run --privileged --rm tonistiigi/binfmt --install all

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Restore node modules from cache
        id: cache-node-modules
        uses: actions/cache@v3
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Install Serverless Framework
        run: sudo yarn global add serverless --prefix /usr/local

      - name: Install dependencies
        working-directory: integration_tests
        run: yarn install

      - name: Run tests
        env:
          BUILD_LAYERS: true
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          RUNTIME_PARAM: ${{ matrix.runtime-param }}
        run: ./scripts/run_integration_tests.sh

      - name: Send success metric
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
        run: ./scripts/send_status_metric.sh 0 $DD_API_KEY

  integration-test-failure:
    runs-on: ubuntu-latest
    needs: [integration-test]
    if: always() && (needs.integration-test.result == 'failure')
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Send a failure metric
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
        run: ./scripts/send_status_metric.sh 1 $DD_API_KEY

  auth:
    runs-on: ubuntu-latest
    steps:
      - id: auth
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
        run: |
          credentials=$(aws sts get-session-token --serial-number ${{ secrets.MFA_DEVICE_ARN }} --token-code ${{ inputs.mfaCode }})

          AWS_ACCESS_KEY_ID=$(echo $credentials | jq -r .Credentials.AccessKeyId)
          echo $AWS_ACCESS_KEY_ID | gpg --quiet --symmetric --cipher-algo AES256 --batch --yes --passphrase ${{ secrets.GPG_PASSPHRASE }} --output aws_access_key.gpg

          AWS_SECRET_ACCESS_KEY=$(echo $credentials | jq -r .Credentials.SecretAccessKey)
          echo $AWS_SECRET_ACCESS_KEY | gpg --quiet --symmetric --cipher-algo AES256 --batch --yes --passphrase ${{ secrets.GPG_PASSPHRASE }} --output aws_secret_access_key.gpg

          AWS_SESSION_TOKEN=$(echo $credentials | jq -r .Credentials.SessionToken)
          echo $AWS_SESSION_TOKEN | gpg --quiet --symmetric --cipher-algo AES256 --batch --yes --passphrase ${{ secrets.GPG_PASSPHRASE }} --output aws_session_token.gpg

      - uses: actions/upload-artifact@v3.1.0
        with:
          name: aws_credentials
          path: |
            aws_access_key.gpg
            aws_secret_access_key.gpg
            aws_session_token.gpg

  build-region-matrix:
    if: ${{ inputs.envToDeploy == 'prod (all regions)' }}
    needs: auth
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v3.0.0
        with:
          name: aws_credentials
      - id: set-matrix
        env:
          AWS_REGION: us-east-1
        run: |
          gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_access_key.txt aws_access_key.gpg
          AWS_ACCESS_KEY_ID=$(cat aws_access_key.txt)
          echo "::add-mask::$AWS_ACCESS_KEY_ID"
          export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID

          gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_secret_access_key.txt aws_secret_access_key.gpg
          AWS_SECRET_ACCESS_KEY=$(cat aws_secret_access_key.txt)
          echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
          export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY

          gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_session_token.txt aws_session_token.gpg
          AWS_SESSION_TOKEN=$(cat aws_session_token.txt)
          echo "::add-mask::$AWS_SESSION_TOKEN"
          export AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN

          echo "::set-output name=aws_region_matrix::$(aws ec2 describe-regions | jq -c '[.Regions | .[] | .RegionName]')"
    outputs:
      aws_region_matrix: ${{ steps.set-matrix.outputs.aws_region_matrix }}

  build-layer-matrix:
    runs-on: ubuntu-latest
    run: |
      chmod +x ./scripts/build_layers.sh
      echo "Building layers"
      ./scripts/build_layers.sh

      echo "::set-output name=layer::$(ls .layers | jq -R -s -c 'split("\n")[:-1]')"

    outputs: ${{ steps.set-matrix.outputs.layer_matrix }}

  deploy-production-layer:
    if: ${{ inputs.envToDeploy == 'prod (all regions)' }}
    needs:
      - build-region-matrix
      - auth
    runs-on: ubuntu-latest
    strategy:
      matrix:
        aws_region: ${{ fromJson(needs.build-matrix.outputs.aws_region_matrix) }}
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - uses: actions/download-artifact@v3.0.0
        with:
          name: aws_credentials
      - name: build-layers
        run: |
          chmod +x ./scripts/build_layers.sh
          ./scripts/build_layers.sh
      - name: deploy
        run: |
          gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_access_key.txt aws_access_key.gpg
          AWS_ACCESS_KEY_ID=$(cat aws_access_key.txt)
          echo "::add-mask::$AWS_ACCESS_KEY_ID"
          export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID

          gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_secret_access_key.txt aws_secret_access_key.gpg
          AWS_SECRET_ACCESS_KEY=$(cat aws_secret_access_key.txt)
          echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
          export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY

          gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_session_token.txt aws_session_token.gpg
          AWS_SESSION_TOKEN=$(cat aws_session_token.txt)
          echo "::add-mask::$AWS_SESSION_TOKEN"
          export AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN

          export AWS_REGION=${{ matrix.aws_region }}

          echo "Building layers"


          result=$(aws lambda publish-layer-version --layer-name maxday-test-from-github-action \
          --description "test from github action" \
          --zip-file "fileb://layer.zip" \
          --region ${{ matrix.aws_region }})

          layer_version=$(echo $result | jq .Version)

          permission=$(aws lambda add-layer-version-permission --layer-name maxday-test-from-github-action \
          --version-number $layer_version \
          --statement-id "release-$layer_version" \
          --action lambda:GetLayerVersion --principal "*" \
          --region ${{ matrix.aws_region }})

deploy-dev-layer:
  if: ${{ inputs.envToDeploy == 'sandbox (sa-east-1)' }}
  needs:
    - auth
    - build-layer-matrix
  runs-on: ubuntu-latest
  strategy:
    matrix:
      layer: ${{ fromJson(needs.build-matrix.outputs.layer_matrix) }}
  steps:
    - name: checkout
      uses: actions/checkout@v3
    - uses: actions/download-artifact@v3.0.0
      with:
        name: aws_credentials
    - name: deploy
      run: |
        export AWS_REGION=sa-east1

        NODE_VERSION=$(echo ${{ matrix.version }} | sed -r 's/^[^0-9]*([0-9]+).*$/\1/')

        gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_access_key.txt aws_access_key.gpg
        AWS_ACCESS_KEY_ID=$(cat aws_access_key.txt)
        echo "::add-mask::$AWS_ACCESS_KEY_ID"
        export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID

        gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_secret_access_key.txt aws_secret_access_key.gpg
        AWS_SECRET_ACCESS_KEY=$(cat aws_secret_access_key.txt)
        echo "::add-mask::$AWS_SECRET_ACCESS_KEY"
        export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY

        gpg --quiet --batch --yes --decrypt --passphrase=${{ secrets.GPG_PASSPHRASE }} --output aws_session_token.txt aws_session_token.gpg
        AWS_SESSION_TOKEN=$(cat aws_session_token.txt)
        echo "::add-mask::$AWS_SESSION_TOKEN"
        export AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN

        result=$(aws lambda publish-layer-version --layer-name ***NEED TO CHANGE*** \
        --description "test from github action" \
        --zip-file "fileb://layer.zip" \
        --region sa-east-1)

        layer_version=$(echo $result | jq .Version)

        permission=$(aws lambda add-layer-version-permission --layer-name ***NEED TO CHANGE*** \
        --version-number $layer_version \
        --statement-id "release-$layer_version" \
        --action lambda:GetLayerVersion --principal "*" \
        --region sa-east-1)
